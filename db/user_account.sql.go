// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_account.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const dBCheckUserBanned = `-- name: DBCheckUserBanned :one
SELECT EXISTS (
  SELECT 1 
  FROM 
    user_account
  WHERE
    username = $1
    AND status = 'banned'
)
`

// Check whether a user_account is banned or not.
func (q *Queries) DBCheckUserBanned(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, dBCheckUserBanned, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const dBCheckUserDisabled = `-- name: DBCheckUserDisabled :one
SELECT EXISTS (
  SELECT 1 
  FROM
    user_account
  WHERE
    username = $1
    AND status = 'disabled'
)
`

// Check whether a user_account is disabled or not.
func (q *Queries) DBCheckUserDisabled(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, dBCheckUserDisabled, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const dBCheckUserExist = `-- name: DBCheckUserExist :one
SELECT EXISTS (
  SELECT 1
  FROM 
    user_account
  WHERE 
    username = $1
)
`

// Check whether a user_account exists or not.
func (q *Queries) DBCheckUserExist(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, dBCheckUserExist, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const dBCreateUserAccount = `-- name: DBCreateUserAccount :one
INSERT INTO
  user_account (
    username, 
    password_login, 
    password, 
    email, 
    loggedin_at, 
    refresh_token
  )
VALUES
  ($1, true, $2, $3, $4, $5)
RETURNING 
  username, 
  first_name, 
  middle_name,
  last_name,
  gender,
  email, 
  avatar,
  city,
  refresh_token
`

type DBCreateUserAccountParams struct {
	Username     string
	Password     pgtype.Text
	Email        string
	LoggedinAt   interface{}
	RefreshToken pgtype.Text
}

type DBCreateUserAccountRow struct {
	Username     string
	FirstName    pgtype.Text
	MiddleName   pgtype.Text
	LastName     pgtype.Text
	Gender       NullEnumGenderOptions
	Email        string
	Avatar       pgtype.Text
	City         pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) DBCreateUserAccount(ctx context.Context, db DBTX, arg DBCreateUserAccountParams) (DBCreateUserAccountRow, error) {
	row := db.QueryRow(ctx, dBCreateUserAccount,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.LoggedinAt,
		arg.RefreshToken,
	)
	var i DBCreateUserAccountRow
	err := row.Scan(
		&i.Username,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.Gender,
		&i.Email,
		&i.Avatar,
		&i.City,
		&i.RefreshToken,
	)
	return i, err
}

const dBDeleteUserAvatar = `-- name: DBDeleteUserAvatar :one
UPDATE
  user_account
SET
  avatar = null
WHERE
  username = $1
  AND status = 'active'
RETURNING
  avatar
`

func (q *Queries) DBDeleteUserAvatar(ctx context.Context, db DBTX, username string) (pgtype.Text, error) {
	row := db.QueryRow(ctx, dBDeleteUserAvatar, username)
	var avatar pgtype.Text
	err := row.Scan(&avatar)
	return avatar, err
}

const dBDisableUserAccount = `-- name: DBDisableUserAccount :exec
UPDATE
  user_account
SET
  status = 'disabled'
WHERE
  username = $1
  AND status = 'active'
`

func (q *Queries) DBDisableUserAccount(ctx context.Context, db DBTX, username string) error {
	_, err := db.Exec(ctx, dBDisableUserAccount, username)
	return err
}

const dBEditUserAccount = `-- name: DBEditUserAccount :one
UPDATE 
  user_account
SET
  first_name = $2,
  middle_name = $3,
  last_name = $4,
  gender = $5,
  city = $5
WHERE
  username = $1
  AND status = 'active'
RETURNING
  username,
  first_name,
  middle_name,
  last_name,
  gender,
  city
`

type DBEditUserAccountParams struct {
	Username   string
	FirstName  pgtype.Text
	MiddleName pgtype.Text
	LastName   pgtype.Text
	Gender     NullEnumGenderOptions
}

type DBEditUserAccountRow struct {
	Username   string
	FirstName  pgtype.Text
	MiddleName pgtype.Text
	LastName   pgtype.Text
	Gender     NullEnumGenderOptions
	City       pgtype.Text
}

func (q *Queries) DBEditUserAccount(ctx context.Context, db DBTX, arg DBEditUserAccountParams) (DBEditUserAccountRow, error) {
	row := db.QueryRow(ctx, dBEditUserAccount,
		arg.Username,
		arg.FirstName,
		arg.MiddleName,
		arg.LastName,
		arg.Gender,
	)
	var i DBEditUserAccountRow
	err := row.Scan(
		&i.Username,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.Gender,
		&i.City,
	)
	return i, err
}

const dBEditUserAvatar = `-- name: DBEditUserAvatar :one
UPDATE
  user_account
SET
  avatar = $2
WHERE
  username = $1
  AND status = 'active'
RETURNING
  avatar
`

type DBEditUserAvatarParams struct {
	Username string
	Avatar   pgtype.Text
}

func (q *Queries) DBEditUserAvatar(ctx context.Context, db DBTX, arg DBEditUserAvatarParams) (pgtype.Text, error) {
	row := db.QueryRow(ctx, dBEditUserAvatar, arg.Username, arg.Avatar)
	var avatar pgtype.Text
	err := row.Scan(&avatar)
	return avatar, err
}

const dBEnableUserAccount = `-- name: DBEnableUserAccount :exec
UPDATE
  user_account
SET
  status = 'active'
WHERE
  username = $1
  AND status = 'disabled'
`

func (q *Queries) DBEnableUserAccount(ctx context.Context, db DBTX, username string) error {
	_, err := db.Exec(ctx, dBEnableUserAccount, username)
	return err
}

const dBGetUserOnboardingOTP = `-- name: DBGetUserOnboardingOTP :one
SELECT id, username, password, email, otp, created_at, expiry_at
FROM
  user_onboarding
WHERE
  username = $1
  AND expiry_at >= NOW() - INTERVAL '5 minutes'
`

func (q *Queries) DBGetUserOnboardingOTP(ctx context.Context, db DBTX, username string) (UserOnboarding, error) {
	row := db.QueryRow(ctx, dBGetUserOnboardingOTP, username)
	var i UserOnboarding
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Otp,
		&i.CreatedAt,
		&i.ExpiryAt,
	)
	return i, err
}

const dBLoginUser = `-- name: DBLoginUser :one
SELECT 
  username,
  first_name,
  last_name,
  gender,
  email,
  avatar,
  city
FROM 
  user_account
WHERE
  username = $1
  AND password_login = true
  AND password = $2
  AND status = 'active'
`

type DBLoginUserParams struct {
	Username string
	Password pgtype.Text
}

type DBLoginUserRow struct {
	Username  string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Gender    NullEnumGenderOptions
	Email     string
	Avatar    pgtype.Text
	City      pgtype.Text
}

// Check login credentials post hashing the password against an active account.
func (q *Queries) DBLoginUser(ctx context.Context, db DBTX, arg DBLoginUserParams) (DBLoginUserRow, error) {
	row := db.QueryRow(ctx, dBLoginUser, arg.Username, arg.Password)
	var i DBLoginUserRow
	err := row.Scan(
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.Email,
		&i.Avatar,
		&i.City,
	)
	return i, err
}

const dBOnboardUser = `-- name: DBOnboardUser :one
INSERT INTO 
  user_onboarding (
    username, 
    password, 
    email, 
    otp, 
    expiry_at
  )
VALUES
  ($1, $2, $3, $4, $5)
RETURNING 
  username, 
  email, 
  otp, 
  expiry_at
`

type DBOnboardUserParams struct {
	Username string
	Password string
	Email    string
	Otp      string
	ExpiryAt time.Time
}

type DBOnboardUserRow struct {
	Username string
	Email    string
	Otp      string
	ExpiryAt time.Time
}

// Insert a onboarding record with an otp and an expiry time.
func (q *Queries) DBOnboardUser(ctx context.Context, db DBTX, arg DBOnboardUserParams) (DBOnboardUserRow, error) {
	row := db.QueryRow(ctx, dBOnboardUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Otp,
		arg.ExpiryAt,
	)
	var i DBOnboardUserRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.Otp,
		&i.ExpiryAt,
	)
	return i, err
}

const dBVerifyUserOTP = `-- name: DBVerifyUserOTP :one
SELECT
  username,
  password,
  email
FROM
  user_onboarding
WHERE
  username = $1
  AND otp = $2
  AND expiry_at >= NOW() - INTERVAL '5 minutes'
`

type DBVerifyUserOTPParams struct {
	Username string
	Otp      string
}

type DBVerifyUserOTPRow struct {
	Username string
	Password string
	Email    string
}

func (q *Queries) DBVerifyUserOTP(ctx context.Context, db DBTX, arg DBVerifyUserOTPParams) (DBVerifyUserOTPRow, error) {
	row := db.QueryRow(ctx, dBVerifyUserOTP, arg.Username, arg.Otp)
	var i DBVerifyUserOTPRow
	err := row.Scan(&i.Username, &i.Password, &i.Email)
	return i, err
}
