// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_account.sql

package db

import (
	"context"
	"time"
)

const addNewCustomerOtpQuery = `-- name: AddNewCustomerOtpQuery :one
INSERT INTO
  user_onboarding (
    username,
    password,
    email,
    otp,
    expiry_at
  )
VALUES
  ($1, $2, $3, $4, NOW() + INTERVAL '5 minutes')
RETURNING
  username,
  email,
  otp,
  expiry_at
`

type AddNewCustomerOtpQueryParams struct {
	Username string
	Password string
	Email    string
	Otp      string
}

type AddNewCustomerOtpQueryRow struct {
	Username string
	Email    string
	Otp      string
	ExpiryAt time.Time
}

// Insert a onboarding record with an otp and an expiry time.
func (q *Queries) AddNewCustomerOtpQuery(ctx context.Context, db DBTX, arg AddNewCustomerOtpQueryParams) (AddNewCustomerOtpQueryRow, error) {
	row := db.QueryRow(ctx, addNewCustomerOtpQuery,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Otp,
	)
	var i AddNewCustomerOtpQueryRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.Otp,
		&i.ExpiryAt,
	)
	return i, err
}

const checkUserBannedQuery = `-- name: CheckUserBannedQuery :one
SELECT EXISTS (
  SELECT 1
  FROM
    user_account
  WHERE
    username = $1
    AND status = 'banned'
)
`

// Check whether a user_account is banned or not.
func (q *Queries) CheckUserBannedQuery(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, checkUserBannedQuery, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserDisabledQuery = `-- name: CheckUserDisabledQuery :one
SELECT EXISTS (
  SELECT 1
  FROM
    user_account
  WHERE
    username = $1
    AND status = 'disabled'
)
`

// Check whether a user_account is disabled or not.
func (q *Queries) CheckUserDisabledQuery(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, checkUserDisabledQuery, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserExistQuery = `-- name: CheckUserExistQuery :one
SELECT EXISTS (
  SELECT 1
  FROM
    user_account
  WHERE
    username = $1
)
`

// Check whether a user_account exists or not.
func (q *Queries) CheckUserExistQuery(ctx context.Context, db DBTX, username string) (bool, error) {
	row := db.QueryRow(ctx, checkUserExistQuery, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const invalidateOtpQuery = `-- name: InvalidateOtpQuery :one
UPDATE user_onboarding
SET
    expiry_at = NOW()
WHERE
    username = $1
    AND expiry_at > NOW()
RETURNING
    username
`

func (q *Queries) InvalidateOtpQuery(ctx context.Context, db DBTX, username string) (string, error) {
	row := db.QueryRow(ctx, invalidateOtpQuery, username)
	err := row.Scan(&username)
	return username, err
}

const verifyOTPAndCreateAccountQuery = `-- name: VerifyOTPAndCreateAccountQuery :one
WITH verified_user AS (
    SELECT
        username,
        password,
        email
    FROM user_onboarding
    WHERE
        user_onboarding.email = $1
        AND otp = $2
        AND expiry_at >= NOW()
    )
INSERT INTO
    user_account(
        username,
        password_login,
        password,
        email,
        status,
        created_at,
        updated_at
    )
SELECT (
    vu.username,
    true,
    vu.password,
    vu.email,
    'active',
    NOW(),
    NOW()
) FROM verified_user AS vu
WHERE
    vu.username IS NOT NULL
RETURNING
    username
`

type VerifyOTPAndCreateAccountQueryParams struct {
	Email string
	Otp   string
}

// OTP verification and account creation in a single query
func (q *Queries) VerifyOTPAndCreateAccountQuery(ctx context.Context, db DBTX, arg VerifyOTPAndCreateAccountQueryParams) (string, error) {
	row := db.QueryRow(ctx, verifyOTPAndCreateAccountQuery, arg.Email, arg.Otp)
	var username string
	err := row.Scan(&username)
	return username, err
}
